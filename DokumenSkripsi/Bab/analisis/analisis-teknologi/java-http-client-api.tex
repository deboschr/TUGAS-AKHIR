Selain Jsoup yang digunakan untuk mengambil dan memproses halaman situs web, sistem ini juga membutuhkan mekanisme pemeriksaan terhadap tautan lain, baik tautan eksternal maupun tautan non-halaman (misalnya berkas gambar, skrip, atau sumber daya lain). Untuk kebutuhan ini dipilih Java HTTP Client API, sebagaimana dijelaskan pada Subbab~\ref{sec:020700-java-http-client-api}. API ini merupakan bagian resmi dari Java sejak versi 11, sehingga tidak memerlukan pustaka tambahan dan terintegrasi langsung dengan ekosistem bahasa Java.  

Pemanfaatan Java HTTP Client API sejalan dengan beberapa kebutuhan non-fungsional, antara lain penerapan batas waktu (\textit{timeout}) agar pemeriksaan tidak menggantung terlalu lama, pengendalian laju permintaan melalui konfigurasi \texttt{HttpClient}, serta dukungan eksekusi paralel yang memanfaatkan sifat \textit{thread-safe} dari objek \texttt{HttpClient}. Dari sisi fungsional, API ini memungkinkan sistem untuk memperoleh status kode HTTP dari setiap tautan, yang kemudian ditampilkan dengan label yang jelas pada antarmuka (lihat Subsubbab~\ref{subsec:030301-kebutuhan-fungsional} dan Subsubbab~\ref{subsec:030302-kebutuhan-non-fungsional}).

Beberapa kelas dan method utama dari API ini yang dapat digunakan dalam implementasi adalah sebagai berikut:

\begin{itemize}[itemsep=2mm]
  \item \texttt{HttpClient}: Kelas ini dipakai sebagai titik masuk untuk membangun klien HTTP. Objek dibuat melalui \texttt{HttpClient.newBuilder()}, dengan konfigurasi penting seperti \texttt{version()} untuk memilih protokol HTTP/1.1 atau HTTP/2, \texttt{connectTimeout(Duration)} untuk menetapkan batas waktu koneksi, dan \texttt{followRedirects()} untuk menentukan kebijakan pengalihan. Objek yang dihasilkan bersifat \textit{immutable} dan \textit{thread-safe}, sehingga dapat digunakan secara bersamaan oleh banyak \textit{thread} pemeriksaan.

  \item \texttt{HttpRequest}: Kelas ini digunakan untuk menyusun permintaan HTTP yang akan dikirim. Metode \texttt{uri(URI)} menentukan alamat tujuan, sementara \texttt{header()} dipakai untuk menyertakan informasi tambahan seperti \texttt{User-Agent}. Jenis operasi HTTP ditentukan dengan \texttt{method()} atau \texttt{GET()}, sedangkan \texttt{timeout(Duration)} memastikan setiap permintaan memiliki batas waktu pemrosesan.

  \item \texttt{HttpResponse}: Objek ini merepresentasikan hasil tanggapan dari server. Informasi utama yang digunakan adalah kode status HTTP melalui \texttt{statusCode()}, \textit{header} melalui \texttt{headers()}, serta isi respon melalui \texttt{body()}. Data ini akan dicatat dan ditampilkan pada antarmuka, termasuk untuk mengidentifikasi tautan rusak (misalnya dengan status 404) atau tautan yang terblokir.

  \item \texttt{HttpHeaders}: Digunakan untuk membaca seluruh \textit{header} dari respon, misalnya \texttt{Content-Type} atau \texttt{Set-Cookie}. Informasi ini relevan untuk analisis tambahan, namun yang paling penting adalah mendukung pelabelan hasil pemeriksaan agar pengguna dapat memahami konteks status setiap tautan.
\end{itemize}

\vspace{3mm}

Kode~\ref{lst:httpclient-example} menunjukkan contoh penggunaan Java HTTP Client API untuk melakukan permintaan HTTP ke sebuah alamat web dan menampilkan hasil tanggapannya. Kode ini ditulis untuk menggambarkan bagaimana kelas-kelas utama yang telah dijelaskan sebelumnya, yaitu \texttt{HttpClient}, \texttt{HttpRequest}, \texttt{HttpResponse}, dan \texttt{HttpHeaders}, digunakan secara bersama-sama dalam sebuah program nyata. Hasil eksekusi dari kode ini berupa informasi \textit{status code}, daftar \textit{header}, serta isi \textit{response body} yang diterima dari server tujuan.

\vspace{20mm}

% \begin{lstlisting}[language=Java, caption={Contoh penggunaan Java HTTP Client API}, label={lst:httpclient-example}]
% public class HttpClientExample {
%     public static void main(String[] args) throws Exception {
%         HttpClient client = HttpClient.newBuilder()
%                 .version(HttpClient.Version.HTTP_2)
%                 .connectTimeout(Duration.ofSeconds(5))
%                 .followRedirects(HttpClient.Redirect.NORMAL)
%                 .build();

%         HttpRequest request = HttpRequest
%                 .newBuilder(URI.create("https://informatika.unpar.ac.id"))
%                 .header("User-Agent", "BrokenLinkChecker 1.0")
%                 .timeout(Duration.ofSeconds(10))
%                 .GET()
%                 .build();

%         HttpResponse<String> response = client.send(
%                 request, HttpResponse.BodyHandlers.ofString()
%         );

%         System.out.println("Status Code : " + response.statusCode());

%         HttpHeaders headers = response.headers();

%         Map<String, List<String>> headerMap = headers.map();

%         for (Map.Entry<String, List<String>> e : headerMap.entrySet()) {
%             String name = e.getKey();
%             String values = String.join(", ", e.getValue());
%             System.out.println(name + ": " + values);
%         }

%         System.out.println("Body        : " + response.body());
%     }
% }
% \end{lstlisting}

\begin{lstlisting}[language=Java, caption={Contoh penggunaan Java HTTP Client API}, label={lst:httpclient-example}]
public class HttpClientExample { 
    public static void main(String[] args) throws Exception { 

        HttpClient client = HttpClient.newBuilder()
                // Menetapkan versi protokol HTTP yang digunakan
                .version(HttpClient.Version.HTTP_2)
                // Menetapkan batas waktu maksimal proses pembentukan koneksi
                .connectTimeout(Duration.ofSeconds(5))
                // Mengatur kebijakan penanganan redirect
                .followRedirects(HttpClient.Redirect.NORMAL)
                // Membangun objek HttpClient dengan konfigurasi yang telah ditentukan
                .build();

        HttpRequest request = HttpRequest
                // Menentukan URI tujuan dari request HTTP
                .newBuilder(URI.create("https://informatika.unpar.ac.id"))
                // Menambahkan header User-Agent untuk mengidentifikasi client
                .header("User-Agent", "BrokenLinkChecker 1.0")
                // Menetapkan batas waktu maksimal 10 detik untuk request
                .timeout(Duration.ofSeconds(10))
                // Menetapkan metode HTTP GET sebagai jenis request
                .GET()
                // Membangun objek HttpRequest berdasarkan konfigurasi yang diberikan
                .build();

        // Mengirim request HTTP secara sinkron menggunakan HttpClient
        HttpResponse<String> response = client.send(
                // Menentukan bahwa response body akan diproses dalam bentuk String
                request, HttpResponse.BodyHandlers.ofString()
        );

        // Mengambil seluruh header dari response HTTP
        HttpHeaders headers = response.headers();
        
        // Mengonversi header menjadi struktur Map
        Map<String, List<String>> headerMap = headers.map();
        for (Map.Entry<String, List<String>> e : headerMap.entrySet()) {
            String name = e.getKey();
            String values = String.join(", ", e.getValue());
            System.out.println(name + ": " + values);
        }
            
        System.out.println("Status Code : " + response.statusCode());
        System.out.println("Body        : " + response.body());
    }
}
\end{lstlisting}


\vspace{3mm}

Alur dari Kode~\ref{lst:httpclient-example} dimulai dengan pembuatan objek \texttt{HttpClient} melalui \texttt{newBuilder()} dan penetapan beberapa konfigurasi, yaitu versi protokol HTTP melalui \texttt{version()}, batas waktu koneksi dengan \texttt{connectTimeout()}, serta kebijakan \textit{redirect} menggunakan \texttt{followRedirects()}. Setelah itu dipanggil \texttt{build()} untuk menghasilkan objek \texttt{HttpClient}. Berikutnya, sebuah \texttt{HttpRequest} dibangun dengan \texttt{HttpRequest.newBuilder(URI)} untuk menentukan alamat tujuan, kemudian ditambahkan informasi tambahan melalui \texttt{header()}, ditetapkan batas waktu menggunakan \texttt{timeout()}, dan jenis operasi HTTP dipilih dengan \texttt{GET()}, lalu diselesaikan dengan \texttt{build()}. Permintaan tersebut dikirim menggunakan \texttt{HttpClient.send()} dengan parameter \texttt{HttpResponse.BodyHandlers.ofString()}, sehingga isi \textit{response body} diproses menjadi \textit{string}. Hasil eksekusi berupa objek \texttt{HttpResponse} yang menyediakan \textit{status code}, kumpulan \textit{header}, serta isi \textit{response body}. Daftar \textit{header} diperoleh dari \texttt{HttpHeaders.map()}, kemudian ditampilkan seluruhnya dalam bentuk pasangan \textit{name-value}, diikuti dengan pencetakan isi \textit{response body}.
